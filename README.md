# OnionApp

### Описание:
Простой сервер

### Что использовалось:
* ASP.NET Core
* Postgres

### Цели проекта:
Изучить
* Onion architecture
* Unit тесты

Использовалась информация об Onion architecture из сайта CodeMaze
https://code-maze.com/onion-architecture-in-aspnetcore/

### Описание структуры решения:
В решении 5 проектов:
* AppDomain
* AppService
* AppInfrastructure
* OnionApp (Presentation layer)
* OnionApp.Tests

Ниже их подробное описание.

* AppDomain
  Слой Domain отвечает за описание прямого взаимодействия работы с данными в БД и различных неполадок.
  Слой состоит из:
  1. Модели сущностей
  2. Абстракции репозиториев
  3. Исключения
  
* AppService
  Service слой должен отвечать за логику обработки данных из БД (бизнес-логика).
  Однако, в моем проекте он по просто дублирует функционал из репозиториев.
  Service layer состоит из:
  1. Абстракции сервисов
  2. Их реализация
  3. Описание DTO объектов для передачи данных в Presentation layer.
     Presentation layer НЕ взаимодействует напрямую с Domain layer.
  4. Mappers для преобразования сущностей из БД в DTO и обратно.

* AppInfrastructure
  Слой Infrastructure отвечает за способ взаимодействия с данными.
  Предполагается, что при замене проекта отвечающего за Infrastructure layer, на другой(напр. при замене БД), 
  в других проектах необходимо будет изменить... ничего.
  Данный слой состоит из:
  1. Реализация репозиториев.
  ~. Всё остальное содержимое относится к реализации, а не к архитектуре.
  
* OnionApp (Presentation layer):
  1. Контроллеры
  2. Валидация

* OnionApp.Tests
  Тут тесты. Тестировалось НЕ всё.


***** Заметки *****

* Валидация данных
  В текущем проекте, Action Filters используются для реализации логики по валидации 
отдельных аргументов контроллеров, а в Service Layer - для валидации их совокупности.
Звучит логично, но.
  При тестировании возникли проблемы с валидацией длины строк(например email).
Предполагалось, что контроллер, при получении слишком длинного email, должен 
выбрасывать неотловленное исключение из БД, т.к. проверка длины email производится
в ActionFilter.
  Однако, InMemoryDatabase игнорирует невалидные данные, несмотря на то, что
конфигурации для моделей прописаны в реализации класса, наследуемого от DbContext.
Поэтому, для упрощения тестирования имеет смысл выполнять некоторую проверку данных
в Service Layer, т.к. InMemoryDatabase не выбрасывает исключений. К тому же 
разбросанная логика валидации выглядит достаточно неудобным для понимания проекта.
  Возможно, в будущем, имеет смысл передавать в ServiceLayer любые необработанные
данные, и проверять их там.

* Модели
  Возможность удаления сущностей User в контроллере отсутствует.
Удаление предусмотрено только, при удалении связанной с User сущности Account.
  Сама логика разделения данных выглядела весьма хорошей перед написанием
данного учебного решения, но на практике выяснилось, что будет лучше,
если в будущем подобные сущности я буду объединять в одну.
